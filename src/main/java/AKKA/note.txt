AKKA提供一种Actor并发模型，其粒度比线程小很多，这意味着你可以在项目中使用大量的Actor。
Akka提供了一套容错机制，允许在Actor出错时进行一些恢复或者重置操作
AKKA不仅可以在单击上构建高并发程序，也可以在网络中构建分布式程序，并提供位置透明的Actor定位服务

Akka是一种高度可扩展的软件，这不仅仅表现在性能方面，也表现在它所适用的应用的大小。Akka的核心，Akka-actor是非常小的，可以非常方便地放进你的应用中，
提供你需要的异步无锁并行功能，不会有任何困扰。

提供excaly once语义保证。


AKKA封装了状态和行为的抽象，一切的通信方式都是基于交换消息来完成，
交换的消息放在接收方的邮箱(Inbox)里.也就是说Actor之间并不直接通信,
而是通过了消息来相互沟通,每一个Actor都把它要做的事情都封装在了它的内部.


每一个Actor是可以有状态也可以是无状态的,理论上来讲,每一个Actor都拥有属于自己的轻量级线程,

保护它不会被系统中的其他部分影响.因此,我们在编写Actor时,就不用担心并发的问题.
通过Actor能够简化锁以及线程管理,Actor具有以下的特性:

提供了一种高级的抽象,能够封装状态和操作.简化并发应用的开发.
提供了异步的非阻塞的/高性能的事件驱动模型
超级轻量级的线程事件处理能力.


近年来随着Spark的火热，Spark本身使用的开发语言Scala、用到的分布式内存文件系统Tachyon
（现已更名为Alluxio）以及基于Actor并发编程模型的Akka都引起了大家的注意。了解过Akka或者Actor的人应该知道，这的确是一个很不错的框架，按照Akka官网的描述——使用Akka使得构建强有力的并发与分布式应用将更加容易。由于历史原因，很多Web系统在开发分布式服务时首先会选择RMI(Remote Method Invoke ,远程方法调用)、RPC(Remote Procedure Call Protocol,远程过程调用)或者使用JMS（Java Messaging Service,Java消息服务）。

   但是使用RMI只能使用java语言，而且开发、执行效率都不高；RPC框架虽然可以通过匹配方法签名的方式比RMI更灵活，但是其存在调用超时、调用丢失等缺点；JMS方式虽然可以通过At Least Delivery Once、消息持久化等机制保证消息不会丢失，但是只能作为一种跨服务的生产者、消费者编程模型使用。Akka不但处理了以上问题，而且还可以使用Actor作为并发编程模型，减少java多线程编程的阻塞、调度、上下文开销甚至死锁等问题。此外，Akka还提供了集群Sharding、流处理等功能的支持，更易于实现有限状态自动机等功能。所以有心的开发者势必会关心如何在最常见的Java系统中使用它，如何与spring集成？

   本文参考Akka官方使用文档，根据自身的经验和理解，提供Akka与Spring集成的方案。本文不说明Spring框架的具体使用，并从Spring已经配置完备的情况开始叙述。






